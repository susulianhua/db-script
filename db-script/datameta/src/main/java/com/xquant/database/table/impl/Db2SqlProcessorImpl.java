/**
 * Copyright (c) 2012-2017, www.tinygroup.org (luo_guo@icloud.com).
 * <p>
 * Licensed under the GPL, Version 3.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * http://www.gnu.org/licenses/gpl.html
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.xquant.database.table.impl;

import com.xquant.database.config.table.Index;
import com.xquant.database.config.table.Table;
import com.xquant.database.config.table.TableField;
import com.xquant.database.exception.DatabaseRuntimeException;
import com.xquant.database.table.TableSqlProcessor;
import org.apache.commons.lang.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;


public class Db2SqlProcessorImpl extends SqlProcessorImpl {
    private static TableSqlProcessor tableSqlProcessor = new Db2SqlProcessorImpl();
    protected String currentDbSchema = null;
    private Logger logger = LoggerFactory
            .getLogger(Db2SqlProcessorImpl.class);
    private List<String> cacheSeqList = null;

    public static TableSqlProcessor getTableSqlProcessor() {
        tableSqlProcessor.setTableProcessor(TableProcessorImpl.getTableProcessor());
        return tableSqlProcessor;
    }

    protected String getDatabaseType() {
        return "db2";
    }

    protected String appendIncrease() {
        return " GENERATED BY DEFAULT AS IDENTITY (START WITH 1, INCREMENT BY 1 )";
    }


    protected String createAlterTypeSql(String tableName, String fieldName,
                                        String tableDataType) {
        return String.format("ALTER TABLE %s ALTER COLUMN %s SET DATA TYPE %s", tableName, delimiter(fieldName), tableDataType);
    }


    protected String getSchema(String schema, Connection connection) throws SQLException {
        ResultSet rs = null;
        //优先获取table上的schema
        if (!StringUtils.isBlank(schema)) {
            return schema;
        }
        //currentDbSchema不为空则从数据库中查询
        if (StringUtils.isBlank(currentDbSchema)) {
            Statement statement = null;
            try {
                statement = connection.createStatement();
                rs = statement.executeQuery("values current schema");
                if (rs.next()) {
                    currentDbSchema = rs.getString(1);
                    currentDbSchema = StringUtils.trim(currentDbSchema);
                }
            } catch (SQLException e) {
                throw new DatabaseRuntimeException(e);
            } finally {
                if (rs != null) {
                    rs.close();
                }
                if (statement != null) {
                    try {
                        statement.close();
                    } catch (SQLException e) {

                    }
                }
            }
        }
        return currentDbSchema;
    }

    protected void getChangedFooterComment(Connection connection, Table table, List<String> list) throws SQLException {
        defaultChangedFooterComment(connection, table, list);
    }

    protected String dealTableName(String tableName) {
        return tableName != null ? tableName.toUpperCase() : null;
    }

    /**
     * 检查数据类型是否相同
     *
     * @param dbColumnType
     * @param tableDataType
     * @return
     */
    protected boolean checkTypeSame(String dbColumnType, String tableDataType, String dbDataType) {
        String tbDataTypeLower = tableDataType.replaceAll(" ", "")
                .replaceAll(",0", "").toLowerCase();

        //我们认为精度为0不需要做为比较对象
        return dbColumnType.replaceAll(",0", "").indexOf(tbDataTypeLower) != -1;
    }

    protected String getSchema(Table table, DatabaseMetaData metadata) throws SQLException {
        return getSchema(table.getSchema(), metadata.getConnection());
    }


    protected void appendComment(String comment, StringBuffer ddlBuffer) {
    }

    protected void appendFooter(StringBuffer ddlBuffer, Table table, List<String> list) {
        super.appendFooter(ddlBuffer, table, list);
        appendFooterComment(table, list);
    }

    /**
     * 添加oracle的字段备注信息
     *
     * @param comment
     * @param ddlBuffer
     * @param list
     */
    protected void appendComment(String comment, StringBuffer ddlBuffer, List<String> list) {
        //do nothing
    }

    /**
     * oracle注释在foot上
     * 不需要在字段中体现变化
     *
     * @param standardComment
     * @param remarks
     * @return
     */
    protected boolean checkCommentSame(String standardComment, String remarks) {
        return true;
    }


    protected String getDropIndexBaseSql(String dropIndexName, String tableName) {
        return String.format("DROP INDEX %s", delimiter(dropIndexName));
    }

    private String getSeqSql(String schema) {
        String queryStr = "SELECT SEQNAME from SYSCAT.SEQUENCES ";
        if (schema != null && schema.trim().length() > 0) {
            queryStr += " WHERE SEQUENCE_OWNER='"
                    + schema.toUpperCase() + "'";
        }
        return queryStr;
    }

    private List<String> getAllSequence(Connection connection, String schema) throws SQLException {
        Statement statement = null;
        ResultSet rs = null;
        List<String> seqlist = new ArrayList<String>();
        try {
            statement = connection.createStatement();
            rs = statement.executeQuery(getSeqSql(schema));
            if (cacheSeqList != null) {
                return cacheSeqList;
            }
            cacheSeqList = new ArrayList<String>();
            while (rs.next()) {
                String seq = rs.getString(1);
                if (seq != null) {
                    seq = seq.toUpperCase();
                }
                seqlist.add(seq);
            }
            cacheSeqList.addAll(seqlist);
        } finally {
            if (statement != null) {
                statement.close();
            }
            if (rs != null) {
                rs.close();
            }
        }
        return cacheSeqList;
    }

    public List<String> getClearTableSql(Table table, Connection connection) throws SQLException {
        List<String> clearSqls = new ArrayList<String>();
        clearSeq(clearSqls, table, connection);
        return clearSqls;
    }

    private void clearSeq(List<String> clearsqls, Table table, Connection connection) throws SQLException {
        boolean isSeqExits = getAllSequence(connection, table.getSchema()).contains(getSeqName(table));
        if (isSeqExits) {
            clearsqls.add(String.format("DROP SEQUENCE %s", getSeqName(table)));
            logger.error( "表格[{0}]在数据库中不存在,将清理残留的序列[{1}]", table.getName()
                    , getSeqName(table));
        }
    }

    protected void dealDefaultValueUpdate(StringBuffer alterTypeBuffer, String fieldDefaultValue, String columnDef) {
        //原来非空现在为null
        if (columnDef != null && fieldDefaultValue == null) {
            alterTypeBuffer.append(" DEFAULT NULL");
        } else {
            appendDefaultValue(fieldDefaultValue, alterTypeBuffer);
        }
    }

    protected void dealNotNullSql(StringBuffer alterTypeBuffer, TableField field, boolean dbNullAble) {
        if (field.getNotNull()
                && dbNullAble) {//类型有变化,且not null
            alterTypeBuffer.append(" NOT NULL");
        } else if (!field.getNotNull()
                && !dbNullAble) {//类型有变化,且null
            alterTypeBuffer.append(" NULL");
        }
    }

    protected boolean checkIndexBaseSame(Index tableIndex, Map<String, String> dbIndexMap,
                                         Connection con) {
        boolean isDbReverse = isIndexReverse(tableIndex, con);
        boolean isIndexReverse = false;
        if (tableIndex.getReverse() != null) {
            isIndexReverse = tableIndex.getReverse();
        }
        return super.checkIndexBaseSame(tableIndex, dbIndexMap, con) && isDbReverse == isIndexReverse;
    }

    private boolean isIndexReverse(Index tableIndex, Connection con) {
        Statement statement = null;
        ResultSet rs = null;
        try {
            statement = con.createStatement();
            rs = statement.executeQuery(String.format("select INDEX_TYPE from user_indexes where index_name='%s'",
                    tableIndex.getName().toUpperCase()));
            if (rs.next()) {
                String indexType = rs.getString("INDEX_TYPE");
                if ("NORMAL/REV".equalsIgnoreCase(indexType)) {
                    return true;
                }
            }
        } catch (SQLException e) {
            throw new DatabaseRuntimeException(e);
        } finally {
            if (statement != null) {
                try {
                    statement.close();
                } catch (SQLException e) {

                }
            }
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException e) {

                }
            }
        }
        return false;
    }

    protected void appendIndexReverse(StringBuffer ddlBuffer, Index index) {
        if (index.getReverse() != null
                && index.getReverse().booleanValue() == true) {
            ddlBuffer.append(" REVERSE");
        }
    }

    private String getSeqName(Table table) {
        return "SEQ_" + table.getNameWithOutSchema().toUpperCase();
    }
}
